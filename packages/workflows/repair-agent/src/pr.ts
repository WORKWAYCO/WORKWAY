/**
 * Pull Request Creation Step
 *
 * Creates GitHub PR with diagnosis and fix details.
 */

import type { Diagnosis } from './diagnose';
import type { Fix } from './fix';
import type { TestResult } from './test';

export interface PRInput {
  diagnosis: Diagnosis;
  fix: Fix;
  error: {
    message: string;
    fingerprint: string;
    repo: string;
  };
  isHighRisk?: boolean;
  testResults?: TestResult;
}

export interface PullRequest {
  url: string;
  number: number;
}

export async function createPR(
  input: PRInput,
  githubToken: string
): Promise<PullRequest> {
  const { diagnosis, fix, error, isHighRisk, testResults } = input;

  // High-risk warning banner
  const riskWarning = isHighRisk
    ? `
> ‚ö†Ô∏è **HIGH-RISK FIX** - This repair affects critical code paths. Extra review required.
>
> The repair agent has classified this as high-risk due to:
> - Potential impact on critical functionality
> - Complex code changes required
> - Insufficient test coverage for affected areas

`
    : '';

  // Prepare PR body
  const body = `
${riskWarning}## Error Repair

**Error Fingerprint:** \`${error.fingerprint}\`

### Diagnosis

**Root Cause:** ${diagnosis.root_cause}

**Confidence:** ${diagnosis.confidence}

**Risk Assessment:** ${diagnosis.risk_assessment}

**Affected Files:**
${diagnosis.affected_files.map((f) => `- ${f}`).join('\n')}

### Fix

${fix.changes_summary}

**Files Changed:**
${fix.commits[0].files_changed.map((f) => `- ${f}`).join('\n')}

### Test Results

${testResults ? formatTestResults(testResults) : '‚ö†Ô∏è No test results available'}

### Suggested Approach

${diagnosis.suggested_approach}

---

ü§ñ Generated by WORKWAY Error Repair Agent

**Review Checklist:**
- [ ] Root cause analysis is accurate
- [ ] Fix addresses the root cause (not just symptoms)
- [ ] Tests cover the error case
- [ ] No unintended side effects
- [ ] Risk assessment is acceptable
`;

  // Create PR via GitHub API
  const [owner, repo] = parseRepo(error.repo);

  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/pulls`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${githubToken}`,
        Accept: 'application/vnd.github.v3+json',
        'User-Agent': 'WORKWAY-Repair-Agent/1.0',
      },
      body: JSON.stringify({
        title: isHighRisk
          ? `‚ö†Ô∏è fix: ${diagnosis.root_cause.slice(0, 65)}`
          : `fix: ${diagnosis.root_cause.slice(0, 72)}`,
        body,
        head: fix.branch,
        base: 'main',
      }),
    }
  );

  if (!response.ok) {
    throw new Error(`GitHub API error: ${response.status} ${await response.text()}`);
  }

  const pr = await response.json();

  return {
    url: pr.html_url,
    number: pr.number,
  };
}

function parseRepo(repo: string): [string, string] {
  // Map repo name to GitHub owner/repo
  const mapping: Record<string, [string, string]> = {
    'workway-platform': ['WORKWAYCO', 'workway-platform'],
    Cloudflare: ['WORKWAYCO', 'WORKWAY'],  // Cloudflare is inside WORKWAY repo
  };

  return mapping[repo] || ['WORKWAYCO', repo];
}

function formatTestResults(results: TestResult): string {
  const lines: string[] = [
    `- ‚úÖ Passed: ${results.passed}`,
    `- ‚ùå Failed: ${results.failed}`,
    `- ‚è≠Ô∏è Skipped: ${results.skipped}`,
    `- ‚è±Ô∏è Duration: ${results.duration_ms}ms`,
  ];

  if (results.timed_out) {
    lines.push('- ‚ö†Ô∏è **TIMED OUT**');
  }

  if (results.failing_tests && results.failing_tests.length > 0) {
    lines.push('');
    lines.push('**Failing Tests:**');
    results.failing_tests.forEach((test) => {
      lines.push(`  - \`${test}\``);
    });
  }

  return lines.join('\n');
}
